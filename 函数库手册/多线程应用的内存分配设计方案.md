<center><font size='6'>多线程应用的内存分配设计方案</font></center>
<br/>
<center><font size='5'>荣涛</font></center>
<center><font size='5'>科教与实训部</font></center>
<center><font size='5'>2020年12月</font></center>
<br/>

# 1. 概述

## 1.1. 设计背景

### 1.1.1. VOS内存分配器

现有VOS内存分配器采用内存池架构，初始化阶段采用 `malloc`进行大块内存的分配（`128*1024*1024`=`128MB`），然后采用内核内存管理的**slab机制**对大块内存进行管理。
在内存分配过程中调用接口`VOS_Malloc`进行内存申请，调用`VOS_Free`进行内存释放，值得注意的是在释放阶段，并没有将内存归还给OS，而是通过**slab机制**归还给了初始化阶段申请的`128MB`内存。但是，在`CentOS 7.4`原生发布的`glibc-2.17`中已经支持在对`chunk bins`的回收功能。
`VOS_Malloc`和`VOS_Free`接口：
```c
/** 
 * 分配内存
 * @param[in]   ulSize      申请内存的大小
 * @param[in]   ulModuleId  申请模块的模块ID
 * @return      成功时返回申请内存的地址，失败则返回NULL。
 */ 
#define VOS_Malloc(ulSize,ulModuleId) VOS_MallocWithDebug(ulSize,ulModuleId,(UCHAR *)__FILE__,__LINE__)

/** 
 * 释放VOS_Malloc申请的内存
 * @param[in]   ptr      释放内存的指针
 */ 
#define VOS_Free(ptr) VOS_Free_Debug(0, ptr,(UCHAR *)__FILE__,__LINE__)
```
其中对`ulModuleId`，`__FILE__`，`__LINE__`的处理以及slab机制，均涉及到资源同步锁问题，无疑降低了VOS内存分配释放的性能。
下面是采用单线程对**VOS内存分配器**和`glibc-2.17`
```
 Malloc>> 653497 MicroSec Total Spend.
    VOS>> 4791108 MicroSec Total Spend.
```

### 1.1.2. ptmalloc,jemalloc,tcmalloc内存分配器

关于《内存分配器ptmalloc,jemalloc,tcmalloc调研与对比》文档已经对现有的内存分配器做出了概述与对比试验，实验结论如下：

1. 对**多线程应用**支持，tcmalloc和jemalloc分配器性能较佳。
以下为在40核心的服务器上采用16线程往复 `malloc` `free`的测试结果，从结果看出，多线程应用情形下的性能 `tcmalloc` > `jemalloc` > `ptmalloc(glibc)`
![](_v_images/20201204143717927_12216.png)


## 1.2. 预期目标



**`TODO`**

## 1.3. 缩略词与名词

1. ptmalloc：glibc内存分配器
2. jemalloc：FaceBook内存分配器
3. tcmalloc：Google内存分配器
4. 

# 2. 设计思路



## 2.1. 几种工业软件的对比


### 2.1.1. Redis

在`redis-6.0.5`中，`zmalloc.h`中是这样指派内存分配器的：
```c
#if defined(USE_TCMALLOC)
#define ZMALLOC_LIB ("tcmalloc-" __xstr(TC_VERSION_MAJOR) "." __xstr(TC_VERSION_MINOR))
#include <google/tcmalloc.h>
#if (TC_VERSION_MAJOR == 1 && TC_VERSION_MINOR >= 6) || (TC_VERSION_MAJOR > 1)
#define HAVE_MALLOC_SIZE 1
#define zmalloc_size(p) tc_malloc_size(p)
#else
#error "Newer version of tcmalloc required"
#endif

#elif defined(USE_JEMALLOC)
#define ZMALLOC_LIB ("jemalloc-" __xstr(JEMALLOC_VERSION_MAJOR) "." __xstr(JEMALLOC_VERSION_MINOR) "." __xstr(JEMALLOC_VERSION_BUGFIX))
#include <jemalloc/jemalloc.h>
#if (JEMALLOC_VERSION_MAJOR == 2 && JEMALLOC_VERSION_MINOR >= 1) || (JEMALLOC_VERSION_MAJOR > 2)
#define HAVE_MALLOC_SIZE 1
#define zmalloc_size(p) je_malloc_usable_size(p)
#else
#error "Newer version of jemalloc required"
#endif

#elif defined(__APPLE__)
#include <malloc/malloc.h>
#define HAVE_MALLOC_SIZE 1
#define zmalloc_size(p) malloc_size(p)
#endif

#ifndef ZMALLOC_LIB
#define ZMALLOC_LIB "libc"
#ifdef __GLIBC__
#include <malloc.h>
#define HAVE_MALLOC_SIZE 1
#define zmalloc_size(p) malloc_usable_size(p)
#endif
#endif
```
可以看出，对于处理高并发的redis对内存分配器的选择顺序是 `USE_TCMALLOC` `USE_JEMALLOC` `__GLIBC__`。
从redis源码中可以看出，redis没有在初始化阶段分配大块内存。
对于接收网口消息，redis采用在栈上分配：`char buf[1024*16];`
```c
/* Use this function to handle a read event on the descriptor. It will try
 * and read some bytes from the socket and feed them to the reply parser.
 *
 * After this function is called, you may use redisGetReplyFromReader to
 * see if there is a reply available. */
int redisBufferRead(redisContext *c) {
    char buf[1024*16];
    int nread;

    /* Return early when the context has seen an error. */
    if (c->err)
        return REDIS_ERR;

    nread = c->funcs->read(c, buf, sizeof(buf));
    if (nread > 0) {
        if (redisReaderFeed(c->reader, buf, nread) != REDIS_OK) {
            __redisSetError(c, c->reader->err, c->reader->errstr);
            return REDIS_ERR;
        } else {
        }
    } else if (nread < 0) {
        return REDIS_ERR;
    }
    return REDIS_OK;
}
```
最终，对于每个请求，redis将从内存分配器中 malloc 新的内存：
```c
newsh = s_malloc(hdrlen+newlen+1);
```
这里的s_malloc对应 
```c
#define s_malloc zmalloc
```
而这里的 zmalloc会调用 宏 malloc， 宏malloc来源于：
```c
/* Explicitly override malloc/free etc when using tcmalloc. */
#if defined(USE_TCMALLOC)
#define malloc(size) tc_malloc(size)
#define calloc(count,size) tc_calloc(count,size)
#define realloc(ptr,size) tc_realloc(ptr,size)
#define free(ptr) tc_free(ptr)
#elif defined(USE_JEMALLOC)
#define malloc(size) je_malloc(size)
#define calloc(count,size) je_calloc(count,size)
#define realloc(ptr,size) je_realloc(ptr,size)
#define free(ptr) je_free(ptr)
#define mallocx(size,flags) je_mallocx(size,flags)
#define dallocx(ptr,flags) je_dallocx(ptr,flags)
#endif
```
可见，redis并没有实现内存池，而是直接使用了内存分配器的 `malloc` 和 `free` 函数。

### 2.1.2. Memcached

`memcached 1.6.7`.
在memcached中采用的是slab机制，默认初始化64MB大小的内存块。由于memcached实现的slab机制的性能参数略差于glibc 的 ptmalloc 内存分配器，这里不对其做详述。
```c
settings.maxbytes = 64 * 1024 * 1024; /* default is 64MB */
```
通过在memcached源码中添加测试例，采用单线程对**memcached的内存分配器**和`glibc-2.17`的**ptmalloc内存分配器**进行对比，结果如下：
```c
  Slabs>> 4245885 MicroSec
 Malloc>> 3250928 MicroSec
```
可见，性能相差大约 `1/4`。
>值得注意的是，memcached的slabs机制中，建议操作系统使用大页内存：

```c
/* This works because glibc simply uses mmap when the alignment is
* above a certain limit. */
ret = posix_memalign(&ptr, pagesize, limit);
if (ret != 0) {
    fprintf(stderr, "Failed to get aligned memory chunk: %d\n", ret);
    return NULL;
}

ret = madvise(ptr, limit, MADV_HUGEPAGE);
if (ret < 0) {
    fprintf(stderr, "Failed to set transparent hugepage hint: %d\n", ret);
    free(ptr);
    ptr = NULL;
}
```

### 2.1.3. Nginx

Nginx同样基于slab机制。这里直接给出对比结果：（往复malloc 和 free 1500 bytes大小500w次）

```c
          Total      Alloc       Test       Free
Glibc    2491425     270460    1973646     247319 82364 kB
Nginx    2418689     301960    1886377     230352 86368 kB
```


### 2.1.4. 小结

从上面三个开源软件的内存分配机制/器对比来看，`memcached`和`nginx`实现了slab机制（与Linux内核内存管理相同，VOS也采用此机制）来管理内存块，redis采用tcmalloc/jemalloc/ptmalloc进行内存管理。
从内存分配、释放的对比试验可以看出：

1. redis采用的tcmalloc内存分配器对于多线程应用的性能略高于jemalloc；
2. tcmalloc和jemalloc内存分配对于多线程应用的性能略高于ptmalloc(glibc)；
3. 通过对比试验，memcached 和 nginx 实现的slab内存管理机制，性能略低于 ptmalloc(glibc)；

基于以上几点的考虑

## 2.2. 多线程应用设计





**`TODO`**

# 3. 设计方案



# 4. 结论



# 5. 相关文档


1. 《内存分配器ptmalloc,jemalloc,tcmalloc调研与对比》

<br/>
<div align=right>Rong Tao
</div>